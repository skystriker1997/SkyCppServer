## 													Backtracking

The backtracking is commonly applied in case of traversing all potential permutations or combinations and it is usually based on recursion to go through all options. In each execution of function, some tasks are done, and most likely calling self again is also part of tasks. When necessary tasks are done, some changes on variables caused by the execution of those tasks, should be revoked to make them look as if the execution never happened. This kind of cancelation is the truth of backtracking. 

Here is the pseudocode:

```cpp
void foo() {
		...
		my_queue_.push(1);
		foo();
		my_queue_.pop();    // backtrace
		...
}
```

my_queue is plugged in 1. After that, it calls self, which may incur a chain of recursions afterwards. Since the stack zone of the callee is released when it returns, the caller do not need to take care of items in stack generated by callee.  When we return from a chain of recursions, PC is set as the start address of the first instruction of my_queue_.pop(), canceling the changes made before. 

Practical case1: [LeetCode 216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/) 

My solution:

```cpp
class Solution {
public:
    vector<vector<int>> combins_;
  
    vector<int> combin_;
  
    vector<vector<int>> combinationSum3(int k, int n) {
        recur(1, k, n);
        return combins_;
    }
  
    void recur(int i, int k, int n) {
        for(i; i<10; i++) {
            combin_.push_back(i);
            if(combin_.size() == k) {
                int s = 0;
                for(int j=0; j<k; j++) {
                    s += combin_[j];
                }
                if(s==n) {
                    combins_.push_back(combin_);
                }
            } else {
                recur(i+1, k, n);
            }
            combin_.pop_back();     
        }  
    }
};
```

Practical case2: [LeetCode 78. Subsets](https://leetcode.com/problems/subsets/) 

My solution:

```cpp
class Solution {
public:
    vector<vector<int>> sets_;

    vector<int> set_;

    vector<vector<int>> subsets(vector<int>& nums) {
        sets_.push_back(set_);
        int n = nums.size();
        recur(0, n, nums);
        return sets_;
    }

    void recur(int i, int n, vector<int>& nums) {
        for(i; i<n; i++) {
            set_.push_back(nums[i]);
            sets_.push_back(set_);
            recur(i+1, n, nums);
            set_.pop_back();
        }
    }
};
```
