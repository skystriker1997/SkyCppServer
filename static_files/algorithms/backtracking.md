## 													Backtracking

The backtracking is commonly applied in case of traversing all potential permutations or combinations and is usually embodied by recursion. In each recursion step, some tasks are done, and most likely calling self is also part of tasks. When necessary tasks are done, some changes on variables caused by the execution of those tasks, should be revoked to make them look as if the execution never happened. This kind of cancelation is the truth of backtracking. 

Here is the pseudocode:

```cpp
void foo() {
		...
		my_queue_.push(1);
		foo();
		my_queue_.pop();    // backtrace
		...
}
```

my_queue inserts 1. After that, it calls self, which may incur a chain of recursive calls afterwards. Since the stack zone of the callee is released when it returns, the caller does not need to take care of items in stack generated by callee.  When the process returns from a chain of recursive calls, PC is set as the start address of the first instruction of my_queue_.pop(), canceling the changes made before. 

I will elaborate Leetcode problems to examplify above concepts. 

Case1: [LeetCode 216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/) 

In Leetcode problems, the main part of the recursive function is generally a for loop that traverse potential options, and in each iteration, if the option is selected and the path has not reached the end point, I make a recursive call to further build up the path based on choices made before. As for options that we go through within for loop, they are mutually exclusive, so they cannot affect each other (i.e. if I used option A, then option B's status should be unused). This is the reason why before next iteration, current iteration should cancel changes it made before. 

Reminder that i+1 is the first argument passed to the recursive call. This is saying no looking back to prevent duplication. 

My solution:

```cpp
class Solution {
public:
    vector<vector<int>> result_;
  
    vector<int> path_;
  
    vector<vector<int>> combinationSum3(int k, int n) {
        recur(1, k, n);
        return result_;
    }
  
    void recur(int i, int k, int n) {
        for(i; i<10; i++) {
            path_.push_back(i);
            if(path_.size() == k) {
                int s = 0;
                for(int j=0; j<k; j++) {
                    s += path_[j];
                }
                if(s==n) {
                    result_.push_back(path_);
                }
            } else {
                recur(i+1, k, n);
            }
            path_.pop_back();     
        }  
    }
};
```

Case2: [LeetCode 78. Subsets](https://leetcode.com/problems/subsets/) 

My solution:

```cpp
class Solution {
public:
    vector<vector<int>> result_;

    vector<int> path_;

    vector<vector<int>> subsets(vector<int>& nums) {
        result_.push_back(path_);
        int n = nums.size();
        recur(0, n, nums);
        return result_;
    }

    void recur(int i, int n, vector<int>& nums) {
        for(i; i<n; i++) {
            path_.push_back(nums[i]);
            result_.push_back(path_);
            recur(i+1, n, nums);
            path_.pop_back();
        }
    }
};
```

Case3: [LeetCode 47. Permutations II](https://leetcode.com/problems/permutations-ii/) 

In this case, I introduced a handy vector used_ to dynamically record which options have been used, sorted nums before using it so that any duplication is consecutive. The key statement proventing duplication is ``` if(i>0 && nums[i-1]==nums[i] && used_[i-1]==false) continue;``` Reminder that in for loop, i goes from 0 to the upper limit, so index i-1 is tested before index i. ```used_[i-1]``` taking false implies that index i-1 is already examined in the for loop, since each iteration of for loop restores it's altered ```used_[i]``` back to false before turning into the next iteration. If ```nums[i-1]==nums[i]```, then they make the same effect from the angle of using for loop to pick out one. In combination, the above statement ensures to forgo such case to avoid duplication.

My solution:

```cpp
class Solution {
public:

    vector<int> path_;

    vector<vector<int>> result_;

    vector<bool> used_;

    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for(int i = 0; i<nums.size(); i++) {
            used_.push_back(false);
        }
        recur(nums);
        return result_;
    }

    void recur(vector<int>& nums) {
        for(int i=0; i<nums.size(); i++) {
            if(used_[i]==false) {     // if it's already used I cannot take it into account
                if(i>0 && nums[i-1]==nums[i] && used_[i-1]==false)
                    continue;
                path_.push_back(nums[i]);
                used_[i]=true;
                if(path_.size()==nums.size()) {
                   result_.push_back(path_);
                } else recur(nums);
                path_.pop_back();
                used_[i]=false;
            }
        }
    }
};
```
